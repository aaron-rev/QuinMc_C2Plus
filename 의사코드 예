중복 확인 함수(비교할 열2, 비교할 열1, 열1의 요소 지시 변수, 열의 요소 개수)
{
	for( 열2의 모든 요소 확인 )
	{
		if(열2의 요소와 열1의 요소가 동일한 경우 존재)
			return false
	}
	return true
}

Prime implicant 복사 함수(prime implicant를 저장할 배열, prime implicant를 찾을 열, 사용 횟수 측정 배열, prime implicant 개수) 
{
	for(prime implicant를 찾을 열의 모든 요소를 확인)
	{
		if(한 번도 비교된 적이 없는 요소 존재)
		{

			prime[prime implicant 개수] <- 한 번도 비교된 적이 없는 요소
			prime implicant 개수 1 증가
		}
	}
}

마지막 column을 prime배열로 옮기는 함수(마지막 column, prime 배열, prime implicant 개수)
{
	for(column의 모든 요소에 대해 시행)
	{
		prime[prime implicant 개수] <- column 요소
		prime implicant 개수 1 증가
	}
}

행에 있는 1의 개수 세는 함수(1의 개수를 셀 행, 행의 요소 개수)
{
	count : 행의 1 개수를 저장할 함수
	count <- 0으로 초기화
	
	for(행의 모든 요소를 확인함)
		if(행의 요소 중 1이 존재) count 1 증가

	return count
}

전체 트랜지스터 개수를 구하는 함수(EssentialPI의 개수, EssentialPI 목록)
{
	A : AND게이트 트랜지스터 개수 저장할 변수 선언
	O : OR게이트 트랜지스터 개수 저장할 변수 선언
	N : 인버터 트랜지스터 개수 저장할 변수 선언
	
	A <- AND게이트 트랜지스터 개수
	O <- OR게이트 트랜지스터 개수 
	N <- 인버터 트랜지스터 개수 

	return A + O + N
}

AND게이트 트랜지스터 개수를 구하는 함수(EssentialPI의 개수, EssentialPI 목록)
{
	ACount : '0'과 '1'의 개수를 저장할 변수
	ACount <- 0으로 초기화

	Acount 변수 <- 전체 EPI의 '0'과 '1'의 개수
	
	AND 게이트 트랜지스터의 개수 <- ACount * 2 + EssentialPI의 개수 * 2

	return AND 게이트 트랜지스터 개수
}

인버터 트랜지스터 개수를 구하는 함수(EssentialPI의 개수, EssentialPI 목록)
{
	NCount : 체크된 자리 개수를 저장할 변수
	NCount <- 0으로 초기화
	
	CheckNot : '0'이 사용된 자리 위치를 나타낼 int형 배열을 비트수만큼 동적할당
	CheckNot <- 배열을 0으로 초기화

	for(모든 EssentialPI를 확인함)
	{
		for(각 EssentialPI의 모든 요소를 확인함)
		{
			if(EssentialPI의 요소에 '0'이 있음)
			{
				그 요소가 있는 위치를 나타내는 CheckNot 배열 요소 <- 1
			}	
		} 
	}
	
	NCount <- 모든 CheckNot 배열 요소의 합
	인버터 트랜지스터 개수 <- 2 * NCount

	return 인버터 트랜지스터 개수
}

무한 반복문 빠져나갈 시점 정하는 함수(PI테이블, 확인행, 행의 요소 개수)
{
	for(확인행의 모든 요소를 확인함)
	{
		if(확인행의 요소 중 1이 아닌 값이 존재)
			return false
	}
	return true
}
